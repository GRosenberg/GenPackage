delimiters "%", "%"
import "D:\DevFiles\Java\WorkSpaces\Main\GenProject\src\net\certiv\antlr\project\libs\Header.stg"
import "D:\DevFiles\Java\WorkSpaces\Main\GenProject\src\net\certiv\antlr\project\libs\Elements.stg"

BaseDescriptorClassCopyright() ::= <<
 * Copyright (c) 2008-2014 G Rosenberg.
 * 
>>

BaseDescriptorClassContributor() ::= <<
 *		G Rosenberg - initial API and implementation
 * 
>>

BaseDescriptorClassVersion() ::= <<
 * 		1.0 - 2014.03.26: First release level code
 * 		1.1 - 2014.08.26: Updates, add Tests support
 * 
>>

BaseDescriptorClass(packageName, grammarName) ::= <<
%hdrBeg()%
%BaseDescriptorClassCopyright()%
%epl()%
%hdrBlankLn()%
%hdrContribPrefix()%
%BaseDescriptorClassContributor()%
%hdrBlankLn()%
%hdrVersionPrefix()%
%BaseDescriptorClassVersion()%
%hdrBlankLn()%
%hdrEnd()%
package %packageName%.converter;

import java.util.ArrayList;
import java.util.List;

import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ParseTree;

import %packageName%.symbol.Symbol;
import %packageName%.util.Strings;

public abstract class BaseDescriptor implements IDescriptor {

	// reference to carry data
	public PhaseState state;

	// context reference
	public ParserRuleContext ctx;

	// local state data
	protected StringBuilder sb;
	public boolean resolved = false; // node resolved?
	public Value value; // the node value
	public List<String> properties; // node properties

	// Comment Collection ///////////////////////////

	// Helpers are in PhaseBase
	private boolean collectComments = false;
	private String commentLeft = "";
	private String commentRight = "";

	// BaseDescriptor Helpers /////////////////////

	public BaseDescriptor(ParserRuleContext ctx) {
		this.ctx = ctx;
	\}

	public void setPhaseState(PhaseState state) {
		this.state = state;
	\}

	public BaseDescriptor getDescriptor(ParseTree ctx) {
		return state.nodeContextMap.get(ctx);
	\}

	@Override
	public String content() {
		return sb.toString();
	\}

	@Override
	public void initialize() {
		value = Value.TRUE;
	\}

	@Override
	public Value processOnEntry() {
		return process();
	\}

	@Override
	public Value processOnExit() {
		return process();
	\}

	@Override
	public Value process(String property) {
		if (properties == null) {
			properties = new ArrayList<>();
		\}
		properties.add(property);
		return process();
	\}

	@Override
	public Value process() {
		return value;
	\}

	@Override
	public String toString() {
		String strValue = value.toString() != null ? value.toString() : "<Null Value>";
		if (collectComments) {
			return getLeftComment() + strValue + Strings.SP + getRightComment();
		\} else {
			return strValue;
		\}
	\}

	@Override
	public void setCollectComments(boolean collect) {
		this.collectComments = collect;
	\}

	@Override
	public boolean getCollectComments() {
		return this.collectComments;
	\}

	@Override
	public void setLeftComment(String comment) {
		this.commentLeft = comment;
	\}

	@Override
	public void setRightComment(String comment) {
		this.commentRight = comment;
	\}

	@Override
	public String getLeftComment() {
		return commentLeft;
	\}

	@Override
	public String getRightComment() {
		return commentRight;
	\}

	// Symbol Table Helpers ///////////////////////////

	protected String vName = "";
	protected Symbol sym = null;

	public Symbol findVarByName(String name) {
		return state.symTable.currentScope().resolve(name);
	\}

	public boolean inCurrentScope(Symbol sym) {
		return state.symTable.currentScope().genId == sym.genId();
	\}

	public Value getVarValue(String name) {
		Symbol sym = findVarByName(name);
		if (sym != null) {
			value = sym.getDescriptor().value;
		\} else {
			value = Value.INVALID;
		\}
		return value;
	\}

	public void setVarValue(Value value) {
		if (sym != null) {
			sym.getDescriptor().value = value;
			this.value = value;
		\} else {
			value = Value.INVALID;
		\}
	\}
\}


>>

DescriptorClassCopyright() ::= <<
 * Copyright (c) 2008-2014 G Rosenberg.
 * 
>>

DescriptorClassContributor() ::= <<
 *		G Rosenberg - initial API and implementation
 * 
>>

DescriptorClassVersion() ::= <<
 * 		1.0 - 2014.03.26: First release level code
 * 		1.1 - 2014.08.26: Updates, add Tests support
 * 
>>

DescriptorClass(packageName) ::= <<
%hdrBeg()%
%DescriptorClassCopyright()%
%epl()%
%hdrBlankLn()%
%hdrContribPrefix()%
%DescriptorClassContributor()%
%hdrBlankLn()%
%hdrVersionPrefix()%
%DescriptorClassVersion()%
%hdrBlankLn()%
%hdrEnd()%
package %packageName%.converter.descriptors;

import java.util.List;

import org.antlr.v4.runtime.tree.TerminalNode;

import %packageName%.converter.BaseDescriptor;
import %packageName%.converter.Value;
import %packageName%.parser.gen.JsonParser.ArrayContext;
import %packageName%.parser.gen.JsonParser.ValueContext;


>>

ImportNamedContextsLiteral(packageName, grammarName, namedContexts) ::= <<
// Generated imports 
%ImportNamedContexts(packageName, grammarName, namedContexts)%
>>

DescriptorBody(contextName) ::= <<
public class %contextName%Descriptor extends BaseDescriptor {

	public %contextName%Descriptor(%contextName%Context ctx) {
		super(ctx);
	\}

	@Override
	public String content() {
		return sb.toString();
	\}

	@Override
	public void initialize() {
		value = Value.TRUE;
	\}

	@Override
	public Value processOnEntry() {
		sb = new StringBuilder();
		sb.append(getLeftComment());
		return value;
	\}

	@Override
	public Value process() {
		if (!resolved) {
			resolved = true;
		\}
		return value;
	\}

	@Override
	public Value processOnExit() {
		sb.append(getRightComment());
		return value;
	\}
	
>>

AccessMethodsLiteral(contextMethods) ::= <<
// Generated access methods
	%AccessMethods(contextMethods)%
>>

DescriptorEnd(contextName) ::= <<
public %contextName%Context context() {
		return (%contextName%Context) ctx;
	\}
\}


>>
