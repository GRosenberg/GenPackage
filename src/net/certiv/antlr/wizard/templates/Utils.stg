delimiters "%", "%"

LogClass(packageName) ::= <<
package %packageName%.util;

import org.apache.log4j.Logger;

public class Log {

	private static Logger logger = Logger.getLogger(Log.class);

	private static Level LogLevel = Level.WARN;

	public static enum Level {
		DEBUG(5),
		INFO(4),
		WARN(3),
		ERROR(2),
		FATAL(1),
		SILENT(0);

		private int priority;

		Level(int priority) {
			this.priority = priority;
		}

		public boolean check() {
			return this.priority <= LogLevel.priority;
		}

		public static Level getValue(String level) {
			Level found = WARN;
			try {
				found = Level.valueOf(level.trim().toUpperCase());
			} catch (IllegalArgumentException e) {}
			return found;
		}
	}

	private Log() {}

	public static void setLevel(Level logLevel) {
		Log.LogLevel = logLevel;
	}

	public static void setLevel(String level) {
		setLevel(Level.getValue(level));
	}

	public static void info(Object source, String message) {
		info(source, true, message, null);
	}

	public static void info(Object source, boolean debug, String message) {
		info(source, debug, message, null);
	}

	public static void info(Object source, String message, Throwable e) {
		info(source, true, message, e);
	}

	public static void info(Object source, boolean debug, String message, Throwable e) {
		if (!debug) return;
		if (Level.INFO.check()) {
			logger = Logger.getLogger(source.getClass());
			if (e == null) {
				logger.info(message);
			} else {
				logger.info(message, e);
			}
		}
	}

	public static void debug(Object source, String message) {
		debug(source, true, message, null);
	}

	public static void debug(Object source, boolean debug, String message) {
		debug(source, debug, message, null);
	}

	public static void debug(Object source, String message, Throwable e) {
		debug(source, true, message, e);
	}

	public static void debug(Object source, boolean debug, String message, Throwable e) {
		if (!debug) return;
		if (Level.DEBUG.check()) {
			logger = Logger.getLogger(source.getClass());
			if (e == null) {
				logger.debug(message);
			} else {
				logger.debug(message, e);
			}
		}
	}

	public static void warn(Object source, String message) {
		warn(source, true, message, null);
	}

	public static void warn(Object source, boolean debug, String message) {
		warn(source, debug, message, null);
	}

	public static void warn(Object source, String message, Throwable e) {
		warn(source, true, message, e);
	}

	public static void warn(Object source, boolean debug, String message, Throwable e) {
		if (!debug) return;
		if (Level.WARN.check()) {
			logger = Logger.getLogger(source.getClass());
			if (e == null) {
				logger.warn(message);
			} else {
				logger.warn(message, e);
			}
		}
	}

	public static void error(Object source, String message) {
		error(source, true, message, null);
	}

	public static void error(Object source, boolean debug, String message) {
		error(source, debug, message, null);
	}

	public static void error(Object source, String message, Throwable e) {
		error(source, true, message, e);
	}

	public static void error(Object source, boolean debug, String message, Throwable e) {
		if (!debug) return;
		if (Level.ERROR.check()) {
			logger = Logger.getLogger(source.getClass());
			if (e == null) {
				logger.error(message);
			} else {
				logger.error(message, e);
			}
		}
	}
}

>>

ReflectClass(packageName) ::= <<
package %packageName%.util;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Reflect {

	private Reflect() {}

	public static void set(Object target, String fieldName, Object value) {
		try {
			Field f = target.getClass().getDeclaredField(fieldName);
			f.setAccessible(true);
			f.set(target, value);
		} catch (SecurityException | NoSuchFieldException | IllegalArgumentException | IllegalAccessException e) {
			e.printStackTrace();
		}
	}

	public static void setSuper(Object target, String fieldName, Object value) {
		try {
			Field f = target.getClass().getSuperclass().getDeclaredField(fieldName);
			f.setAccessible(true);
			f.set(target, value);
		} catch (SecurityException | NoSuchFieldException | IllegalArgumentException | IllegalAccessException e) {
			e.printStackTrace();
		}
	}

	public static Object get(Object target, String fieldName) {
		try {
			Field f = target.getClass().getDeclaredField(fieldName);
			f.setAccessible(true);
			return f.get(target);
		} catch (SecurityException | NoSuchFieldException | IllegalArgumentException | IllegalAccessException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static Object getSuper(Object target, String fieldName) {
		try {
			Field f = target.getClass().getSuperclass().getDeclaredField(fieldName);
			f.setAccessible(true);
			return f.get(target);
		} catch (SecurityException | NoSuchFieldException | IllegalArgumentException | IllegalAccessException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static Object invoke(Object target, String methodName, Class<?>[] params, Object[] args) {

		try {
			Method m = target.getClass().getMethod(methodName, params);
			m.setAccessible(true);
			return m.invoke(target, args);
		} catch (SecurityException | NoSuchMethodException | IllegalArgumentException
				| IllegalAccessException | InvocationTargetException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static Object invokeSuperDeclared(Object target, String methodName, Class<?>[] params, Object[] args) {

		try {
			Method m = target.getClass().getSuperclass().getDeclaredMethod(methodName, params);
			m.setAccessible(true);
			return m.invoke(target, args);
		} catch (SecurityException | NoSuchMethodException | IllegalArgumentException
				| IllegalAccessException | InvocationTargetException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static Object make(Class<?> clazz, Object[] args) {
		Constructor<?> c = clazz.getDeclaredConstructors()[0];
		c.setAccessible(true);
		Object object = null;
		try {
			object = c.newInstance(args);
		} catch (SecurityException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
			e.printStackTrace();
		}
		return object;
	}
	
	public static String simpleClassName(Object arg) {
		String name = arg.getClass().getCanonicalName();
		if (name != null) {
			int mark = name.lastIndexOf('.');
			if (mark > 0) {
				return name.substring(mark + 1);
			}
		}
		return "<unknown>";
	}
	
}

>>

StringsClass(packageName) ::= <<
package %packageName%.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;

import %packageName%.converter.Value;

import org.apache.commons.io.FilenameUtils;

public class Strings {

	/** Platform dependent end-of-line marker */
	public static final String eol = System.lineSeparator();
	/** Platform dependent path separator mark */
	public static final char pathSep = File.separatorChar;

	/** classpath (and unix) separator) */
	private static final String STD_SEPARATOR = "/";

	/** Windows separator character for classpath use. */
	private static final String WINDOWS_SEPARATOR = "\\\\";

	/** Reference characters */
	private static char[] R = { '$', '@', '.', '#' };

	/** Quoting character pairs */
	private static char[][] Q = {
			{ '\'', '\'' },
			{ '\"', '\"' },
			{ '[', ']' },
			{ '(', ')' },
			{ '{', '}' },
			{ '<', '>' }
	};

	public static String asString(ArrayList<String> values, boolean asPrefix, String sep) {
		StringBuilder sb = new StringBuilder();
		String pf = asPrefix ? sep : "";
		String sf = asPrefix ? "" : sep;
		for (String value : values) {
			sb.append(pf + value + sf);
		}
		if (!asPrefix) { // removes trailing sep by default
			int beg = sb.length() - 1 - sep.length();
			sb.delete(beg, sb.length());
		}
		return sb.toString();
	}

	public static boolean numeric(String value) {
		if (value.length() == 0) return false; // empty string is a string
		try {
			Double.parseDouble(value);
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
	}

	public static String csvValueList(List<Value> valueList) {
		return csvValueList(valueList, ", ");
	}

	public static String csvValueList(List<Value> valueList, String sep) {
		if (valueList == null) return "";
		StringBuilder sb = new StringBuilder();
		for (Value v : valueList) {
			sb.append(v.basis + sep);
		}
		return sb.toString().substring(0, sb.length() - sep.length());
	}

	public static String csvList(List<String> stringList) {
		if (stringList == null) return "";
		StringBuilder sb = new StringBuilder();
		for (String str : stringList) {
			sb.append(str + ", ");
		}
		int len = sb.length();
		sb.delete(len - 2, len);
		return sb.toString();
	}

	/**
	 * Remove leading reference identifier. No error if the identifier is not present.
	 */
	public static String varName(String varRef) {
		for (int idx = 0; idx < R.length; idx++) {
			if (varRef.charAt(0) == R[idx]) {
				return varRef.substring(1);
			}
		}
		return varRef;
	}

	/**
	 * Remove one level of quotes surrounding the literal. No error if quotes are not present or are mixed.
	 */
	public static String deQuote(String literal) {
		int endIdx = literal.length() - 1;
		if (endIdx < 2) return literal;
		char beg = literal.charAt(0);
		char end = literal.charAt(endIdx);
		for (int idx = 0; idx < Q.length; idx++) {
			if (beg == Q[idx][0] && end == Q[idx][1]) {
				return literal.substring(1, endIdx);
			}
		}
		return literal;
	}

	/**
	 * Convert separators so the string is a valid URL appropriate for classpath discovery
	 */
	public static String concatAsClassPath(String... args) {
		return concat(args).replaceAll(WINDOWS_SEPARATOR, STD_SEPARATOR);
	}

	/**
	 * Generalized concatenation of path strings
	 */
	public static String concat(String... args) {
		String result = "";
		for (String arg : args) {
			result = FilenameUtils.concat(result, arg);
		}
		return result;
	}

	public static String indentBlock(String ci, String block) {
		if (block == null) return "<Error: indent block is null>";
		StringReader sr = new StringReader(block);
		BufferedReader buf = new BufferedReader(sr);
		StringBuilder sb = new StringBuilder();
		String s;
		try {
			while ((s = buf.readLine()) != null) {
				sb.append(ci + s + Strings.eol);
			}
			sb.setLength(sb.length() - Strings.eol.length());
		} catch (IOException e) {
			sb.append("<Error indenting block: " + e.getMessage() + ">");
		}
		return sb.toString();
	}
}

>>

