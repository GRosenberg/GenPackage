delimiters "%", "%"

ConverterClass(packageName, grammarName, startRule) ::= <<
package %packageName%.converter;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

import %packageName%.parser.gen.%grammarName%Lexer;
import %packageName%.parser.gen.%grammarName%Parser;
import %packageName%.util.Log;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;
import org.apache.commons.io.FileUtils;

public class Converter {

	public Converter() {
		super();
	}

	public void convert(File srcFile, File dstFile) {
		Log.info(this, "Converting " + srcFile.getName() + " -> " + dstFile.getName());
		ANTLRInputStream input;
		try {
			FileInputStream is = new FileInputStream(srcFile);
			input = new ANTLRInputStream(is);
		} catch (IOException e) {
			Log.error(this, "Source file not valid.", e);
			return;
		}

		%grammarName%Lexer lexer = new %grammarName%Lexer(input);
		// %grammarName%TokenFactory factory = new %grammarName%TokenFactory(input);
		// lexer.setTokenFactory(factory);
		CommonTokenStream tokens = new CommonTokenStream(lexer);

		%grammarName%Parser parser = new %grammarName%Parser(tokens);
		// parser.setTokenFactory(factory);
		// parser.removeErrorListeners(); // remove default ConsoleErrorListener
		// parser.addErrorListener(new %grammarName%ErrorListener());
		// parser.setErrorHandler(new %grammarName%ParserErrorStrategy());
		ParseTree tree = parser.%startRule%();

		ParseTreeWalker walker = new ParseTreeWalker();
		%grammarName%Phase01 phase01 = new %grammarName%Phase01(tree, tokens);
		walker.walk(phase01, tree);

		%grammarName%Phase02 phase02 = new %grammarName%Phase02(phase01);
		walker.walk(phase02, tree);

		%grammarName%Phase10 phase10 = new %grammarName%Phase10(phase02);
		walker.walk(phase10, tree);

		try {
			FileUtils.write(dstFile, tree.toStringTree());
		} catch (IOException e) {
			Log.error(this, "Failed to write parse tree to file.", e);
		}
	}
}
>>

PhaseBaseClass(packageName, grammarName) ::= <<
package %packageName%.converter;

import java.util.ArrayList;
import java.util.List;

import %packageName%.parser.gen.%grammarName%Lexer;
import %packageName%.parser.gen.%grammarName%ParserBaseListener;

import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeProperty;

public class %grammarName%PhaseBase extends %grammarName%ParserBaseListener {

	public ParseTree tree;
	public CommonTokenStream tokens;
	public ParseTreeProperty<NodeContextDescriptor> nodeContextMap;
	public ArrayList<Integer> commentMarkers;

	/**
	 * Constructor for initial phase
	 */
	public %grammarName%PhaseBase(ParseTree tree, CommonTokenStream tokens) {
		super();
		this.tree = tree;
		this.tokens = tokens;
		this.nodeContextMap = new ParseTreeProperty<NodeContextDescriptor>();
		this.commentMarkers = new ArrayList<Integer>();
	}

	/**
	 * Convenience Constructor for subsequent phases
	 */
	public %grammarName%PhaseBase(%grammarName%PhaseBase prior) {
		this(prior.nodeContextMap, prior.commentMarkers,  prior.tree, prior.tokens);
	}

	/**
	 * Constructor for subsequent phases
	 */
	public %grammarName%PhaseBase(ParseTreeProperty<NodeContextDescriptor> nodeContextMap, ArrayList<Integer> commentMarkers,
			ParseTree tree, CommonTokenStream tokens) {
		super();
		this.nodeContextMap = nodeContextMap;
		this.commentMarkers = commentMarkers;
		this.tree = tree;
		this.tokens = tokens;
	}

	public NodeContextDescriptor getDescriptor(ParseTree ctx) {
		return nodeContextMap.get(ctx);
	}

	public void setDescriptor(ParseTree ctx, NodeContextDescriptor ncd) {
		nodeContextMap.put(ctx, ncd);
	}

	public String childText(ParserRuleContext<Token> rc, int idx) {
		return rc.getChild(idx).getText();
	}

	public String commentLeft(ParserRuleContext<Token> rc) {
		int tdx = rc.getStart().getTokenIndex();
		int jdx = tdx - 1;
		boolean onlyWS = true;
		boolean done = false;
		while (!done) {
			switch (tokens.get(jdx).getType()) {
				case %grammarName%Lexer.COMMENT:
				case %grammarName%Lexer.COMMENT_BLOCK:
					onlyWS = false;
				case %grammarName%Lexer.HWS:
				case %grammarName%Lexer.VWS:
					if (jdx > 0) {
						jdx--;
					} else {
						done = true;
					}
					break;
				default:
					done = true;
			}
		}
		if (onlyWS) return "";
		if (commentMarkers.contains(jdx)) {
			return "";
		} else {
			commentMarkers.add(jdx);
		}

		StringBuilder sb = new StringBuilder();
		for (; jdx < tdx; jdx++) {
			sb.append(tokens.get(jdx).getText());
		}
		return sb.toString();
	}

	public String commentRight(ParserRuleContext<Token> rc) {
		int tdx = rc.getStop().getTokenIndex();
		int jdx = tdx + 1;
		boolean onlyWS = true;
		boolean done = false;
		while (!done) {
			switch (tokens.get(jdx).getType()) {
				case %grammarName%Lexer.COMMENT_LINE:
					onlyWS = false;
				case %grammarName%Lexer.HWS:
					jdx++;
					break;
				case %grammarName%Lexer.EOF:
					done = true;
					break;
				default:
					done = true;
			}
		}
		if (onlyWS) return "";
		if (commentMarkers.contains(jdx)) {
			return "";
		} else {
			commentMarkers.add(jdx);
		}

		StringBuilder sb = new StringBuilder();
		for (tdx++; tdx <= jdx; tdx++) {
			sb.append(tokens.get(tdx).getText());
		}
		return sb.toString();
	}

	/**
	 * Returns the qualified name after removal of the last 'dotted' segment.
	 * 
	 * @param qualifiedName
	 * @return
	 */
	public String removeTerminal(String qualifiedName) {
		int idx = qualifiedName.lastIndexOf('.');
		if (idx == -1) return qualifiedName;
		return qualifiedName.substring(0, idx);
	}

	public List<ParseTree> getRuleContextElements(ParserRuleContext<Token> ctx) {
		return ctx.children;
	}
}
>>
